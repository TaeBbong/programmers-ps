# 정수 삼각형

문제 정보 : 프로그래머스 lv3, DP

[[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]] / 30
트리 형태로 된 맵을 최상단부터 바닥으로 내려가며 최대값 찾기

높이: 1~500
dp[i][j] = i번째 높이에서 j번째 바닥에 도착했을 때 최대값(j <= i)
dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + map[i][j]


(1, 0) => (0, -1) / (0, 0)
(1, 1) => (0, 0) / (0, 1)

(2, 0) => (1, -1), (1, 0)
(2, 1) => (1, 0), (1, 1)


import copy

def solution(triangle):
    dp = copy.deepcopy(triangle)
    for i in range(1, len(triangle)):
        for j in range(0, i + 1):
            cands = []
            if j < i:
                cands.append(dp[i - 1][j])
            if j - 1 >= 0:
                cands.append(dp[i - 1][j - 1])
            dp[i][j] = max(cands) + triangle[i][j]
    answer = max(dp[-1])
    return answer


* tmi
참조 / 얕은 복사 / 깊은 복사
어떤 리스트, 객체가 있을 때 이를 복사하기 위해서 만약 
a = [1, 2, 3]
b = a
와 같이 작성하였다면 이는 복사가 아닌 "참조"
주소값이 복사되며 결국 b와 a는 실제로 같은 메모리의 값을 참조하므로 b의 값 편집 시 a가 편집되는 것과 같은 효과 발생

이를 방지하기 위해 얕은 복사를 실시하면
b = a[:] 또는 b = a.copy()
이러면 b와 a는 별개의 id 값을 갖는 별개의 메모리 공간을 할당받음
대신 얕은 복사는 리스트의 상위 구조, 즉 가장 바깥쪽의 리스트만 새로 생성되는 거고 내부 요소는 원본 리스트의 참조를 그대로 사용
따라서 리스트 안에 리스트가 있는 경우 마찬가지의 문제 발생

깊은 복사를 실시하면
b = copy.deepcopy(a)
이러면 가장 바깥쪽 뿐만 아니라 내부의 모든 원소도 다른 주소를 갖게 됨!
