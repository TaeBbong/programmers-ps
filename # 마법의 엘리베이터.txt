# 마법의 엘리베이터

문제정보 : lv2, 그리디?

10^n으로 k를 만드는 방법 찾기

생각보다 그렇게 경우의 수가 많지 않을 느낌
예를 들어 2554면,
1) 2000 + 554(16)
  554 => 500 + 54(14) / 600 - 46(15)
    54(9) => 50 + 4(9) / 60 - 6(12)
    46(9) => 40 + 6(10) / 50 - 4(9)
2) 3000 - 446
446 => 400 + 46 / 500 - 54
46 => 40 + 6 / 50 - 4
54 => 50 + 4 / 60 - 6

반례 909

1000 - 100

1000 - 91 / 900 + 9
91 => 90 + 1 / 100 - 9
9 => 9(c = 1, q = 9, r = 0) => 10 - 1

1) 현재 자리수를 만드는 최소 방법 결정(어차피 이건 2개 중 하나)
2554 => 2000 --> 2000 / 10000 - 8000
909 => 900 --> 1000 - 100 / 900

2) 현재 자리수 뺀 나머지를 만드는 방법 결정(재귀)
554 => 500, 54 => 50 => 4 => 4
446 => 400, 46 => 40 => 6 => 10-4

9090 => 9000(10000-1000) => 90 => 100-10

이렇게 풀려고 하니, 디테일이 너무 많아서 풀이를 참고
핵심은 10으로 계속 나눠가면서, 나머지가 5보다 작거나 5인데 그 앞자리가 5보다 작은 경우(45)
해당 나머지를 온전히 넣어주고,
그게 아니면 10 - 나머지를 넣어준다.
이때 제일 큰 포인트는, 10 - 나머지하고나서 그 10에 대한 반영을 카운트에서 하는게 아니라,
그 다음 수를 확인할 때 반영해줘야 한다는 것이다..

좀 꼼꼼함과 디테일이 필요했던 문제인 듯 하다.

def elevator(storey):
    if storey == 0:
        return 0
    
    storey, r = storey // 10, storey % 10
    
    if r < 5 or (r == 5 and storey % 10 < 5):
        return r + elevator(storey)
    else:
        return 10 - r + elevator(storey + 1)


def solution(storey):
    return elevator(storey)

참고) 내가 하려는게 이거였음

def solution(storey):
    if storey < 10 :
        return min(storey, 11 - storey)
    left = storey % 10
    return min(left + solution(storey // 10), 10 - left + solution(storey // 10 + 1))