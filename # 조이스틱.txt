# 조이스틱

문제 정보 : lv2, 그리디

위아래는 쉬운데 좌우 이동이 머리 아픔
gpt 행님한테 물어보니 되게 심플하게 답변을 만들어줌
이걸 기반으로 이해를 해보면,

어차피 왔다 갔다가 여러번이면 무조건 손해. 돌아오는건 1번이면 족함
그럼 모든 i에 대해서
1) 처음부터 i만큼 정상주행 했다가, 다시 i만큼 백하고, 뒤에서부터 나머지 이동하는 방법
2) 처음부터 뒤에서 시작해서 나머지 이동하고, 나머지만큼 백하고, 처음부터 i만큼 이동하는 방법

즉 모든 위치에 대해 min 비교를 하게 되는 것..
아직도 제대로 이해는 못한듯

def solution(name: str) -> int:
    n = len(name)
    vertical = sum(min(ord(c) - ord('A'), 26 - (ord(c) - ord('A'))) for c in name)

    move = n - 1
    for i in range(n):
        j = i + 1
        while j < n and name[j] == 'A':
            j += 1
        # 구간 길이 k = j - (i+1), 오른쪽 끝까지 남은 길이 rest
        rest = n - j
        # ① 오른쪽 i칸 → 왼쪽 i칸 되돌아가서 ↺ → 오른쪽으로 rest
        option1 = i * 2 + rest
        # ② 왼쪽(끝)에서 rest칸 먼저 가서 ↺ → 오른쪽 i칸
        option2 = rest * 2 + i

        move = min(move, option1, option2)

    return vertical + move


사고 과정을 간단히 풀어보면 이래요 🙂

문제를 두 축으로 분해

처음 문제를 읽자마자 “▲/▼ 조작”과 “◀/▶ 조작”은 서로 간섭이 없다는 걸 확인했어요. 글자를 바꾸는 비용(세로)과 커서 이동 비용(가로)을 따로 계산해도 합치면 전체 움직임이 되니까, 둘을 완전히 분리했습니다.

세로 이동은 ‘원형 거리’

알파벳이 원형(26칸)으로 이어져 있으니 ‘현재 글자에서 A까지의 시계·반시계 최단 거리’를 고르면 되죠. 글자마다 독립적으로 min(d, 26-d)를 취해 합산하면 끝.

가로 이동은 “우회”가 핵심

단순히 오른쪽으로 끝까지 가는 전략은 쉽지만, 중간에 긴 A(이미 목표값이라 건드릴 필요 없는 구간)를 만나면 돌아갔다가 우회하는 편이 이득일 수 있다는 걸 떠올렸어요.

“맨 처음부터 끝까지 반복 뒤적거리지 말고, ‘A 연속 구간’을 끼고 앞뒤로 한 번 꺾는 패턴만 따져도 되겠다”는 직관이 들었습니다.

그래서 **모든 커서 위치 i를 ‘꺾는 지점 후보’**로 삼고,

오른쪽→왼쪽→오른쪽 왕복,

반대 방향으로 먼저 돌아가서 왕복
두 거리만 계산했죠.
(길이가 20 이하라 전부 돌려도 부담이 없으니 완전탐색해도 O(400) 수준.)

한 줄 루프로 압축

위 아이디어를 코드로 옮기면 “i 이후 첫 A-아닌 위치 j”만 찾으면 거리 식이 깔끔하게 떨어져서, for 하나에 while 하나면 충분했습니다.

결국 “작은 관찰 → 독립적 하위 문제 → 제한된 패턴 완전탐색” 흐름이에요.
문제를 읽고 “이건 조이스틱이니까 수직·수평으로 나누자” → “수평에서만 머리 좀 써보자” → “A 구간을 통과할 때 꺾기” 라는 자연스러운 단계였죠!

결론
추가적인 U턴을 넣을수록 이미 지나친 구간을 한 번 더 왕복하게 되므로
거리만 늘고 이득은 전혀 없다 → 한 번(또는 0번)만 고려하면 충분.

따라서 앞서 드린 코드가 전체 최적해를 완전히 탐색하고 있다는 것이 보장됩니다!