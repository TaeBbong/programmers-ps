# 숫자 게임

문제 정보 : 프로그래머스 lv3, 아이디어? 그리디?

지니어스 흑과백 같은 게임
기본적인 컨셉은 질 때 크게 지고 이길 때 근소하게 이긴다.
질 때 크게 진다 => min vs max
이길 때 근소하게 => x - y = min..

대신 흑과백 이랑 다른 점은 각자가 가지고 있는 카드가 동등하지 않다는 것..
이런 알고리즘을 생각해보자.

0) 상대의 수들 A를 내림차순 정렬
1) 상대의 수 a가 주어짐
2) 내가 가진 수들 B에서 a보다 크면서 가장 작은 b를 찾음 => 근소한 승리
3) 내가 가진 수들 중 a보다 큰게 없음 => 가장 작은 수를 던져서 패배 => 큰 패배

이렇게 하면

7 => 8
5 => 6
3 => 2
1 => 2

==> 주어진 테스트 케이스에서는 통과하긴 하는데, 가장 효과적인 전략이 맞나?

아니면

0) 내가 가진 수들 B의 각 수가 이길 수 있는 애들 수를 count, 이를 기반으로 정렬

8 [5, 3]
6 [5, 3]
2 []





이길 수 있는 수가 가장 적은 친구부터 배치
2 => 1
이때 앞서 2가 1이랑 싸워서 이겼으므로 1은 제외되어야 함
2=> 이길 수 있는게 없음.. => 상대의 가장 큰 수를 제외 => 7
6 => 3
8 => 5

이거 A를 고정 시켜놓고, B의 각 값들이 이길 수 있는 범위를 (i, j)로 관리하면
이기면 => j - 1, 지면 => i + 1

너무 복잡하게 생각했죠..?

걍 A, B 둘다 오름차순 정렬해놓고
가장 작은 b부터 탐색하면서
b가 a의 최솟값(A[0])을 못이기면 del A[-1](가장 큰 애 치우기)
b가 a의 최솟값을 이기면 del A[0]

결국 이게 아까부터 계속 구현하려 했던 아이디어


def solution(A, B):
    answer = 0
    
    if min(A) >= max(B):
        return 0
    
    A = sorted(A)
    B = sorted(B)
    for b in B:
        if b <= A[0]:
            del A[-1]
        else:
            del A[0]
            answer += 1
            
    return answer

