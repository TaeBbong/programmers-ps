# 양궁대회

문제 정보 : lv2, 재귀(dfs) / dp

dp를 선택한 순간 backtracking 등 지옥을 맛볼 것...
그냥 재귀로 모든 경우(먹냐 안먹냐) 따지는게 훨씬 쉽다
dp도 나쁘진 않았는데.. 확 어려워짐

dp 버전
```python
'''
dp[i][k] = 현재까지 총 k개의 화살을 쏴서 i번째 점수까지 왔을 때 최대 점수차
dp[i][k] = max(dp[i - 1][k - info[i]] + score[i], dp[i - 1][k] - score[i])
'''
import copy


def solution(n, info):
    answer = []
    dp = []
    score = [i for i in range(10, -1, -1)]
    for i in range(11):
        dp.append([])
        for j in range(n + 1):
            dp[i].append((0, 0))
    for k in range(0, info[0] + 1):
        dp[0][k] = (-10, k)
    for k in range(info[0] + 1, n + 1):
        dp[0][k] = (10, k)
    
    # print(dp[0])
    for i in range(1, 11):
        for k in range(0, n + 1):
            if k >= info[i] + 1:
                if info[i] == 0:
                    if dp[i - 1][k - 1][0] + score[i] >= dp[i - 1][k][0]:
                        dp[i][k] = (dp[i - 1][k - 1][0] + score[i], 1)
                    else:
                        dp[i][k] = (dp[i - 1][k][0], 0)
                else:
                    if dp[i - 1][k - info[i] - 1][0] + score[i] >= dp[i - 1][k][0] - score[i]:
                        dp[i][k] = (dp[i - 1][k - info[i] - 1][0] + score[i], info[i] + 1)
                    else:
                        dp[i][k] = (dp[i - 1][k][0] - score[i], 0)
            else:
                dp[i][k] = (dp[i - 1][k][0] - score[i], 0)
        # print(dp[i])
    
    MAX = -55
    MAX_ANSWER = []
    # for i in range(10, 10):
    while True:
        i = 10
        k = n
        backtrack = []
        for j in range(i, -1, -1):
            backtrack.append(dp[j][k][1])
            k -= dp[j][k][1]
        backtrack = backtrack[::-1]
        empty = 11 - len(backtrack)
        for j in range(empty):
            backtrack.append(0)
        # print(dp[i][n][0], backtrack)
        if dp[i][n][0] >= MAX:
            MAX = dp[i][n][0]
            rest = 0
            for j in range(0, 11):
                if backtrack[j] > info[j]:
                    rest += backtrack[j] - info[j] - 1
                    backtrack[j] = info[j] + 1
            j = 10
            while rest:
                if backtrack[j] <= info[j]:
                    diff = info[j] - backtrack[j]
                    if rest >= diff:
                        backtrack[j] += diff
                        rest -= diff
                    else:
                        backtrack[j] += rest
                        rest = 0
                        break
                else:
                    backtrack[j] += rest
                    rest = 0
                    break
                j -= 1

            MAX_ANSWER = copy.copy(backtrack)
        break
    
    if MAX <= 0:
        return [-1]
    
    return MAX_ANSWER
```

재귀 버전
```python
import copy


def dfs(play, i, k, info):
    if i == 11:
        if k:
            play[-1] += k
        return [play]
    results = []
    if k >= info[i] + 1:
        results += dfs(play + [info[i] + 1], i + 1, k - info[i] - 1, info)
        results += dfs(play + [0], i + 1, k, info)
    else:
        results += dfs(play + [0], i + 1, k, info)
    return results


def solution(n, info):
    MAX = -55
    MAX_ANSWER = []
    score = [i for i in range(10, -1, -1)]

    plays = dfs([], 0, n, info)
    for play in plays:
        ans = 0
        for i in range(10, -1, -1):
            if play[i] > info[i]:
                ans += score[i]
            else:
                if info[i]:
                    ans -= score[i]
        if ans > MAX:
            MAX_ANSWER = copy.copy(play)
            MAX = ans
        if ans == MAX:
            if ''.join(reversed([str(i) for i in play])) > ''.join(reversed([str(i) for i in MAX_ANSWER])):
                MAX_ANSWER = copy.copy(play)
    if MAX > 0:
        return MAX_ANSWER
    return [-1]
```